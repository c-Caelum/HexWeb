{
  "block.hexparty.impetus.socket": "Wandering Impetus",

  "hexparty.iota.response": "HTTPResponse{%s}",

  "hexparty.mishap.invalid_json_key": "The \"%s\" key is not present within the JsonIota!",
  "hexparty.mishap.cannot_json": "The %s iota has no direct Json translation!",
  "hexparty.mishap.too_early": "You tried accessing a HTTP response before it arrived!",
  "hexparty.mishap.filtered_url": "The url %s is filtered.",
  "hexparty.mishap.packet_too_big": "The data you attempted to send is too big! Size of %s bytes is bigger than 65535 bytes!",
  "hexparty.mishap.no_socket": "The Socket with ID %s does not exist!",
  "hexcasting.mishap.invalid_value.class.json": "a json object",
  "hexcasting.mishap.invalid_value.class.response": "a HTTP response",
  "hexcasting.mishap.invalid_value.class.method": "a string value matching any HTTP request method except CONNECT (GET, FETCH, POST, etc)",
  "hexcasting.mishap.invalid_value.class.headers.list": "a list of key-value string pairs ([key, value, key,...])",
  "hexcasting.mishap.invalid_value.class.headers.json": "a json with only string values",
  "hexcasting.mishap.invalid_value.class.headers": "a list of key-value string pairs or json with only string values",
  "hexcasting.mishap.invalid_value.class.body": "a string or json",
  "hexparty.mishap.translatable": "Expected a json object that has a value key which holds a JsonArray.",


  "hexparty.entry.http_spells": "HTTP Spells",
  "hexparty.page.http_spells.entry": "While pondering the depths of one's mind, Sir Bernes-Lee caught a glimpse into another universe. With this view fresh in his mind, he quickly conjured a JSON object, imbued it with information, and sent it hurdling into the other universe.$(br)These are the patterns recovered after Berners-Lee was found dead having received enough information back to fry his mind.",
  "hexparty.page.http_spells.explanation": "To use the following pattern, one needs a $(thing)URL$() as a string alone.$(br)Optionally, one may also include a $(thing)HTTP method$() as a string (defaults to GET if omitted), $(thing)headers$() as a list of key-value string pairs ([key, value,...]), and a $(thing)body$() as a string.$(br2)Supported $(thing)HTTP Methods$():$(li)GET$(li)POST$(li)PUT$(li)DELETE$(li)HEAD$(li)OPTIONS$(li)PATCH$(li)TRACE",
  "hexcasting.action.hexparty:request": "Request",
  "hexparty.page.http_spells.request": "$(br)Sends an HTTP request to the given $(thing)URL$(). Optionally, the $(thing)method$() used, $(thing)headers$() attached, and the $(thing)body$() of data sent with it may also be specified. Returns a $(thing)Response$() which will be Truthy when the response is received.",
  "hexcasting.action.hexparty:get_response": "Get Response",
  "hexparty.page.http_spells.get_response": "Given a Response from an HTTP request, attempt to parse the results. Will Mishap if too early or an error is thrown.",
  "hexcasting.action.hexparty:get_copyparty": "Get Copyparty",
  "hexparty.page.http_spells.get_copyparty": "Given a path and a password, attempts to make a request to the hexparty path given. You *can* do this with the request pattern, but it is significantly easier to do it this way.",
  "hexcasting.action.hexparty:set_copyparty": "Set Copyparty",
  "hexparty.page.http_spells.set_copyparty": "$(br)Given a path, iotas, and password, attempts to set the file at that hexparty path to the given iotas. You *can* do this with the Request pattern, but it is significantly better to do it this way.",
  "hexcasting.action.hexparty:response_json": "Get Response II",
  "hexparty.page.http_spells.response_json": "Turns the response's body into a pattern list, using json as an intermediary. (Ducky Peripherals' mappings)",
  "hexcasting.action.hexparty:get_code": "Get Status",
  "hexparty.page.http_spells.get_code": "Turns the given response iota into the status code associated with it, or -1 if it is unfinished or it cannot find one."
}